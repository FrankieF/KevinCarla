package  
{
	public class Vision extends GameObject
	{
		
		public function Vision() 
		{
			
			//var detected:Boolean = false;
			//
			//if (changeDirection >= 0)
			//{
				//if (changeDirection > checkDirection)
				//{
					//numberGen = (Math.random() * 360) / 180 * Math.PI;
//
				//}
//
				//var velocity:Point = new Point();
				//var $list:Vector.<GameObject >  = getType(Player);
//
				//var $currentDistance:Number = Number.MAX_VALUE;
//
				//for (var i:int = 0; i < $list.length; i++)
				//{
					//currentPlayer = $list[i];
		//
					//if (MathUtil.isWithinRange(currentPlayer.width,currentPlayer.x,currentPlayer.y, 200,x,y))
					//{
						//trace("Player " + i + " is in the range");
						//var $myPosition:Point = new Point ;
						//$myPosition.x = x;
						//$myPosition.y = y;
						//
						//var $playerPosition:Point = new Point;
						//$playerPosition.x = currentPlayer.x;
						//$playerPosition.y = currentPlayer.y;
						//
						//var $lookPosition:Point = new Point;
						//$lookPosition.x = Math.cos(rotation * (180 / Math.PI)) * 100 + $myPosition.x;
						//$lookPosition.y = Math.sin(rotation * (180 / Math.PI)) * 100 + $myPosition.y;
						//
						//
						//var angleToPlayer:Number = MathUtil.angleBetween($myPosition, $lookPosition, $myPosition, $playerPosition);
						//var angleToPlayer:Number = MathUtil.angleBetween($myPosition, $lookPosition, $playerPosition);
						//
						//trace("angle to player: " + angleToPlayer);
						//
						//trace("position: " + $playerPosition);
						//
						//trace("my rotation: " + rotation);
						//
						//trace("my look direction: " + $lookPosition);
						//
						//trace("angle to player " + angleToPlayer);
						//
						//if(angleToPlayer <= 45 && angleToPlayer >= -45)
						//
						//trace(angleToPlayer);
						//
						//if(angleToPlayer < 48 || angleToPlayer > 360-45) 
						//{
							//detected = true;
							//trace("Player " + i + " is in the sight");
							//var $delta:Point = new Point  ;
							//
							//$delta.x = currentPlayer.x - x;
							//$delta.y = currentPlayer.y - y;
							//
							//if ($currentDistance > $delta.length)
							//{
								//$currentDistance = $delta.length;
								//velocity = $delta;
								//velocity.normalize(speed);
							//}
						//}						
					//}
				//}
				//
				//if (velocity.length == 0)
				//{
					//velocity = Point.polar(2,numberGen);
				//}
//
				//changeDirection--;
//
				//if (changeDirection == 0)
				//{
					//changeDirection = originalValue;
				//}
			//}
//
			//velocity.x = Math.floor(velocity.x * 10) * .1;
			//velocity.y = Math.floor(velocity.y * 10) * .1;
//
//
			//moveBy([Wall, Door], velocity.x, velocity.y, collides_mc);
//
			//var $collides:GameObject = collision([Player]);
			//if ($collides != null)
			//{
				//destroy();
			//}
//
			//if ($collides == null)
			//{
				//$collides = collision([Player],this);
				//if ($collides != null)
				//{
					//$collides.destroy();
				//}
			//}
//
			//rotation = (Math.atan2(velocity.y, velocity.x) * 180 / Math.PI);
			///*
			//if (detected){
				//if (Math.atan2(velocity.y, velocity.x) * 180 / Math.PI > rotation) rotation += rotatingSpeed;
				//else rotation -= rotatingSpeed;
			//}
			//*/
			//collides_mc.rotation =  -  rotation;
			
			
			
			
		}
		
	}

}